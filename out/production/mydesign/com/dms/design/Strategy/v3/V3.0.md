V1.0
Duck超类，实现了quack swim方法
MallardDuck继承Duck，实现display方法
RedheadDuck继承Duck,实现display方法


V2.0
需求：添加会飞的功能
在Duck上添加会飞，导致所有鸭子都会飞，包括橡皮鸭，橡皮鸭不是呱呱叫 是吱吱叫
如果在添加入诱饵鸭，诱饵鸭是个木头假鸭，不会飞也不会叫
体现出来继承的缺点：
    改变会牵一发而动全身，造成其他鸭子不想要的改变
    有新的类型时，要检查方法，并不是所有的子类都具有飞行和呱呱叫的行为
通过接口实现：如果现有代码中有很多个鸭子类型，需逐一检查方法，接口没有实现，所有还要在每个类型
中写方法实现。
设计原则:找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。

V3.0
抽出变化的，通过接口+实现方式
    我们希望一切能有弹性，毕竟，正是因为一开始鸭子行为没有
    弹性，才让我们走上现在这条路。我们还想能够“指定”行为
    到鸭子的实例。比方说，我们想要产生一个新的绿头鸭实例，
    并指定特定“类型”的飞行行为给它。干脆顺便让鸭子的行为
    可以动态地改变好了。换句话说，我们应该在鸭子类中包含设
    定行为的方法，这样就可以在“运行时”动态地“改变”绿头
    鸭的飞行行为。
设计原则
    针对接口编程，而不是针对实现编程
编写接口加实现类的好处：
    这样的设计， 可以让飞行和呱呱叫的动作被其他
    的对象复用，因为这些行为已经与鸭子类无关了。
    而我们可以新增一些行为， 不会影响到既有的行
    为类，也不会影响“使用”到飞行行为的鸭子类。
     可以动态改变行为

策略模式：
    定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于
使用算法的客户。
